#include "channel.chp"

operator&(node<1> a, node<1> b, node<1> s)
{
	[    a & b -> s+
	[] ~(a & b) -> s-
	]
}

operator|(node<1> a, node<1> b, node<1> s)
{
	[    a | b -> s+
	[] ~(a | b) -> s-
	]
}

operator~(node<1> a, node<1> s)
{
	[  ~a -> s+
	[]  a -> s-
	]
}


operator==(node<1> a, node<1> b, node<1> s)
{
	s := a & b | ~a & ~b
}

operator==(node<2> a, node<2> b, node<1> s)
{
	s := (a[0]==b[0]) & (a[1]==b[1])
}

operator==(node<3> a, node<3> b, node<1> s)
{
	s := (a[0]==b[0]) & (a[1]==b[1]) & (a[2]==b[2])
}

operator&(dualrail a, dualrail b, dualrail s)
{
	[a.t&b.t -> s.f-; s.t+
	[]a.f|b.f -> s.t-; s.f+
	]
}

operator|(dualrail a, dualrail b, dualrail s)
{
	[a.t|b.t -> s.f-; s.t+
	[]a.f&b.f -> s.t-; s.f+
	]
}

operator~(dualrail a, dualrail s)
{
	[a.f -> s.f-; s.t+
	[]a.t -> s.t-; s.f+
	]
}

operator^(dualrail a, dualrail b, dualrail s)
{
	s := a&~b | b&~a
}

/*operator+(node<3> a, node<3> b, node<3> s)
{
	node<2> c;
	node<2> axorb;
	
	// First bit with no carry in
	s[0] := a[0]^b[0];
	c[0] := a[0]&b[0];
	
	// Second bit
	axorb[0] := a[1]^b[1];
	s[1] := axorb[0]^c[0];
	c[1] := axorb[0]&c[0] | a[1]&b[1];
	
	// Third bit with no carry out
	axorb[1] := a[2]^b[2];
	s[2] := axorb[1]^c[1]
}*/